<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Face Recognition Biometric Manager with Unlimited Storage">
    <title>xsukax Face Recognition Biometric Manager</title>
    <script src="face-api.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(4px); }
        .modal-content { background-color: #ffffff; margin: 5% auto; padding: 24px; border: none; width: 90%; max-width: 520px; border-radius: 12px; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: modalSlideIn 0.3s ease-out; }
        @keyframes modalSlideIn { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .close { color: #9ca3af; float: right; font-size: 28px; font-weight: bold; cursor: pointer; line-height: 20px; transition: color 0.2s; }
        .close:hover, .close:focus { color: #1f2937; }
        .notification { position: fixed; top: 20px; right: 20px; padding: 16px 20px; border-radius: 10px; color: white; z-index: 1000; min-width: 280px; max-width: 420px; box-shadow: 0 8px 24px rgba(0,0,0,0.2); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform: translateX(0); opacity: 1; }
        .notification.hiding { transform: translateX(450px); opacity: 0; }
        .drop-area { border: 3px dashed #cbd5e0; border-radius: 12px; padding: 40px 20px; text-align: center; transition: all 0.3s ease; cursor: pointer; background: linear-gradient(135deg, #f9fafb 0%, #ffffff 100%); }
        .drop-area:hover { border-color: #60a5fa; background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%); }
        .drop-area.dragover { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-color: #3b82f6; transform: scale(1.02); }
        .person-card { transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%); border: 1px solid #e5e7eb; }
        .person-card:hover { transform: translateY(-6px); box-shadow: 0 12px 32px rgba(0,0,0,0.12); border-color: #3b82f6; }
        .face-image { max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .face-thumbnail { width: 100px; height: 100px; object-fit: cover; border-radius: 10px; margin: 6px; border: 3px solid #e5e7eb; cursor: pointer; transition: all 0.25s ease; }
        .face-thumbnail:hover { border-color: #3b82f6; transform: scale(1.08); box-shadow: 0 6px 16px rgba(59,130,246,0.3); }
        .icon-btn { display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; border-radius: 8px; transition: all 0.2s ease; cursor: pointer; font-size: 20px; }
        .icon-btn:hover { transform: translateY(-2px); }
        .icon-download { color: #059669; }
        .icon-download:hover { background-color: #d1fae5; }
        .icon-edit { color: #2563eb; }
        .icon-edit:hover { background-color: #dbeafe; }
        .icon-delete { color: #dc2626; }
        .icon-delete:hover { background-color: #fee2e2; }
        .match-result { animation: fadeInUp 0.5s ease-out; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .spinner { border: 3px solid #f3f4f6; border-top: 3px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .progress-bar-container { width: 100%; background-color: #e5e7eb; border-radius: 9999px; height: 12px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
        .progress-bar-fill { height: 100%; transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%); border-radius: 9999px; }
        .badge { display: inline-block; padding: 4px 12px; border-radius: 9999px; font-size: 12px; font-weight: 600; }
        .badge-success { background-color: #d1fae5; color: #065f46; }
        .badge-warning { background-color: #fef3c7; color: #92400e; }
        .badge-error { background-color: #fee2e2; color: #991b1b; }
        .badge-info { background-color: #dbeafe; color: #1e40af; }
        .storage-info { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px; border-radius: 8px; font-size: 12px; display: inline-flex; align-items: center; gap: 8px; }
        @media (max-width: 640px) { 
            .modal-content { width: 95%; margin: 10% auto; padding: 16px; } 
            .notification { right: 10px; left: 10px; min-width: auto; } 
            .drop-area { padding: 24px 16px; }
            .face-thumbnail { width: 80px; height: 80px; margin: 4px; }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-50 to-gray-100 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-md border-b-2 border-blue-500">
        <div class="max-w-7xl mx-auto px-4 py-4 sm:py-6 sm:px-6 lg:px-8">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                <div>
                    <h1 class="text-2xl sm:text-3xl font-bold text-gray-900">üîê Face Recognition Manager</h1>
                    <p class="text-sm text-gray-600 mt-1">Unlimited storage with IndexedDB ‚Ä¢ High-quality images</p>
                </div>
                <div class="flex flex-wrap gap-2 items-center">
                    <div id="storageInfo" class="storage-info">
                        <span>üíæ</span>
                        <span id="storageText">Loading...</span>
                    </div>
                    <button id="clearStorageBtn" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-all shadow-md hover:shadow-lg text-sm font-medium">
                        üóë Clear All
                    </button>
                    <button id="exportBtn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-all shadow-md hover:shadow-lg text-sm font-medium">
                        üíæ Export
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto px-4 py-6 sm:py-8 sm:px-6 lg:px-8">
        <!-- Person Management Section -->
        <section class="mb-8">
            <div class="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-3">
                    <div>
                        <h2 class="text-2xl font-bold text-gray-900">üë• Person Management</h2>
                        <p class="text-sm text-gray-600 mt-1">Add and manage registered persons</p>
                    </div>
                    <div class="flex flex-wrap gap-2">
                        <input type="file" id="importData" accept=".json" class="hidden" multiple>
                        <button id="importBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition-all shadow-md hover:shadow-lg text-sm font-medium">
                            üì• Import
                        </button>
                        <button id="addPersonBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all shadow-md hover:shadow-lg text-sm font-medium">
                            ‚ûï Add Person
                        </button>
                    </div>
                </div>
                
                <div id="personContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Person cards will be dynamically inserted here -->
                </div>
            </div>
        </section>

        <!-- Matching Section -->
        <section>
            <div class="bg-white rounded-xl shadow-lg p-6 border border-gray-200">
                <div class="mb-6">
                    <h2 class="text-2xl font-bold text-gray-900">üîç Face Matching</h2>
                    <p class="text-sm text-gray-600 mt-1">Upload an image to identify registered persons</p>
                </div>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-semibold text-gray-900 mb-3">üì∑ Select Image to Match</h3>
                        <div id="matchDropArea" class="drop-area">
                            <div class="text-4xl mb-3">üì∏</div>
                            <p class="text-gray-700 font-medium mb-2">Drag & drop image here</p>
                            <p class="text-gray-500 text-sm mb-4">or click to browse</p>
                            <input type="file" id="matchImageUpload" accept="image/*" class="hidden">
                            <button id="matchBrowseBtn" class="px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all shadow-md hover:shadow-lg font-medium">
                                Browse Files
                            </button>
                        </div>
                        <div id="matchImagePreview" class="mt-4"></div>
                    </div>
                    <div>
                        <h3 class="font-semibold text-gray-900 mb-3">üìä Matching Results</h3>
                        <div id="matchResults" class="space-y-3 min-h-[250px]">
                            <div class="text-center py-16 text-gray-400">
                                <div class="text-5xl mb-3">üë§</div>
                                <p class="text-lg font-medium">No image uploaded</p>
                                <p class="text-sm mt-2">Upload an image to see matching results</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Add Person Modal -->
    <div id="addPersonModal" class="modal">
        <div class="modal-content">
            <span class="close">‚úï</span>
            <h2 class="text-2xl font-bold mb-6 text-gray-900">‚ûï Add New Person</h2>
            <form id="addPersonForm">
                <div class="mb-5">
                    <label class="block text-gray-800 text-sm font-semibold mb-2" for="personName">Full Name *</label>
                    <input type="text" id="personName" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="Enter full name" required>
                </div>
                <div class="mb-6">
                    <label class="block text-gray-800 text-sm font-semibold mb-2" for="personDescription">Description</label>
                    <textarea id="personDescription" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" rows="3" placeholder="Optional description or notes"></textarea>
                </div>
                <div class="flex items-center justify-end gap-3">
                    <button type="button" id="cancelAddPerson" class="px-5 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-all font-medium">Cancel</button>
                    <button type="submit" class="px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all font-medium">Add Person</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Edit Person Modal -->
    <div id="editPersonModal" class="modal">
        <div class="modal-content">
            <span class="close">‚úï</span>
            <h2 class="text-2xl font-bold mb-6 text-gray-900">‚úè Edit Person Details</h2>
            <form id="editPersonForm">
                <input type="hidden" id="editPersonId">
                <div class="mb-5">
                    <label class="block text-gray-800 text-sm font-semibold mb-2" for="editPersonName">Full Name *</label>
                    <input type="text" id="editPersonName" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" required>
                </div>
                <div class="mb-5">
                    <label class="block text-gray-800 text-sm font-semibold mb-2" for="editPersonDescription">Description</label>
                    <textarea id="editPersonDescription" class="shadow-sm appearance-none border border-gray-300 rounded-lg w-full py-3 px-4 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" rows="3"></textarea>
                </div>
                <div class="mb-5">
                    <label class="block text-gray-800 text-sm font-semibold mb-2">Face Images</label>
                    <div id="editFaceImages" class="flex flex-wrap gap-2 mb-3 min-h-[60px] p-3 bg-gray-50 rounded-lg"></div>
                    <div id="editDropArea" class="drop-area">
                        <p class="text-gray-700 font-medium mb-2">Drag & drop images here</p>
                        <input type="file" id="editImageUpload" accept="image/*" multiple class="hidden">
                        <button type="button" id="editBrowseBtn" class="mt-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all font-medium">Add Images</button>
                    </div>
                </div>
                <div class="flex items-center justify-end gap-3">
                    <button type="button" id="cancelEditPerson" class="px-5 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-all font-medium">Cancel</button>
                    <button type="submit" class="px-5 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all font-medium">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <span class="close">‚úï</span>
            <h2 class="text-2xl font-bold mb-4 text-gray-900">‚ö†Ô∏è Confirm Action</h2>
            <p id="confirmMessage" class="mb-6 text-gray-700 text-lg"></p>
            <div class="flex justify-end gap-3">
                <button id="cancelConfirm" class="px-5 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-all font-medium">Cancel</button>
                <button id="confirmAction" class="px-5 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-all font-medium">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Processing Modal -->
    <div id="processingModal" class="modal">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6 text-gray-900">‚öôÔ∏è Processing Images</h2>
            <div class="mb-5">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-medium text-gray-700">Progress</span>
                    <span id="processingText" class="text-sm font-bold text-blue-600">0%</span>
                </div>
                <div class="progress-bar-container">
                    <div id="processingBar" class="progress-bar-fill" style="width: 0%"></div>
                </div>
            </div>
            <div id="processingStatus" class="text-gray-600 text-center py-4">
                <div class="spinner mx-auto mb-3"></div>
                <p>Initializing...</p>
            </div>
        </div>
    </div>

    <!-- Notifications Container -->
    <div id="notificationContainer"></div>

    <script>
        // ===== IndexedDB Database Manager =====
        class BiometricDB {
            constructor() {
                this.dbName = 'BiometricDatabase';
                this.version = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores
                        if (!db.objectStoreNames.contains('persons')) {
                            db.createObjectStore('persons', { keyPath: 'id' });
                        }
                        if (!db.objectStoreNames.contains('faces')) {
                            const faceStore = db.createObjectStore('faces', { keyPath: 'id' });
                            faceStore.createIndex('personId', 'personId', { unique: false });
                        }
                    };
                });
            }

            async savePerson(person) {
                const tx = this.db.transaction(['persons'], 'readwrite');
                const store = tx.objectStore('persons');
                await store.put(person);
                return tx.complete;
            }

            async getPerson(personId) {
                const tx = this.db.transaction(['persons'], 'readonly');
                const store = tx.objectStore('persons');
                return await this.promisifyRequest(store.get(personId));
            }

            async getAllPersons() {
                const tx = this.db.transaction(['persons'], 'readonly');
                const store = tx.objectStore('persons');
                return await this.promisifyRequest(store.getAll());
            }

            async deletePerson(personId) {
                const tx = this.db.transaction(['persons', 'faces'], 'readwrite');
                await tx.objectStore('persons').delete(personId);
                
                // Delete all faces for this person
                const faceStore = tx.objectStore('faces');
                const index = faceStore.index('personId');
                const faces = await this.promisifyRequest(index.getAll(personId));
                
                for (const face of faces) {
                    await faceStore.delete(face.id);
                }
                
                return tx.complete;
            }

            async saveFace(face) {
                const tx = this.db.transaction(['faces'], 'readwrite');
                const store = tx.objectStore('faces');
                await store.put(face);
                return tx.complete;
            }

            async getFacesByPerson(personId) {
                const tx = this.db.transaction(['faces'], 'readonly');
                const store = tx.objectStore('faces');
                const index = store.index('personId');
                return await this.promisifyRequest(index.getAll(personId));
            }

            async deleteFace(faceId) {
                const tx = this.db.transaction(['faces'], 'readwrite');
                const store = tx.objectStore('faces');
                await store.delete(faceId);
                return tx.complete;
            }

            async clearAll() {
                const tx = this.db.transaction(['persons', 'faces'], 'readwrite');
                await tx.objectStore('persons').clear();
                await tx.objectStore('faces').clear();
                return tx.complete;
            }

            async getStorageEstimate() {
                if ('storage' in navigator && 'estimate' in navigator.storage) {
                    return await navigator.storage.estimate();
                }
                return { usage: 0, quota: 0 };
            }

            promisifyRequest(request) {
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            // Helper to convert dataURL to Blob (more efficient storage)
            dataURLtoBlob(dataURL) {
                const arr = dataURL.split(',');
                const mime = arr[0].match(/:(.*?);/)[1];
                const bstr = atob(arr[1]);
                let n = bstr.length;
                const u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], { type: mime });
            }

            // Helper to convert Blob to dataURL
            async blobToDataURL(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }
        }

        // ===== Application State =====
        const state = {
            db: new BiometricDB(),
            currentMatchImage: null,
            selectedPersonId: null,
            modelsLoaded: false
        };

        // ===== DOM Elements =====
        const elements = {
            personContainer: document.getElementById('personContainer'),
            addPersonBtn: document.getElementById('addPersonBtn'),
            importBtn: document.getElementById('importBtn'),
            importData: document.getElementById('importData'),
            exportBtn: document.getElementById('exportBtn'),
            clearStorageBtn: document.getElementById('clearStorageBtn'),
            storageText: document.getElementById('storageText'),
            addPersonModal: document.getElementById('addPersonModal'),
            editPersonModal: document.getElementById('editPersonModal'),
            confirmModal: document.getElementById('confirmModal'),
            processingModal: document.getElementById('processingModal'),
            matchDropArea: document.getElementById('matchDropArea'),
            matchImageUpload: document.getElementById('matchImageUpload'),
            matchBrowseBtn: document.getElementById('matchBrowseBtn'),
            matchImagePreview: document.getElementById('matchImagePreview'),
            matchResults: document.getElementById('matchResults'),
            notificationContainer: document.getElementById('notificationContainer'),
            processingBar: document.getElementById('processingBar'),
            processingText: document.getElementById('processingText'),
            processingStatus: document.getElementById('processingStatus')
        };

        // ===== Initialize Application =====
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await state.db.init();
                await migrateFromLocalStorage();
                await updateStorageInfo();
                await renderPersonData();
                setupEventListeners();
                await loadFaceApiModels();
                
                // Update storage info every 10 seconds
                setInterval(updateStorageInfo, 10000);
            } catch (error) {
                console.error('Initialization error:', error);
                showNotification('‚ö†Ô∏è Failed to initialize database: ' + error.message, 'error');
            }
        });

        // ===== Migrate from localStorage =====
        async function migrateFromLocalStorage() {
            const oldData = localStorage.getItem('biometricData');
            if (!oldData) return;

            try {
                const data = JSON.parse(oldData);
                let migratedCount = 0;

                for (const personId in data) {
                    const person = data[personId];
                    const { faces, ...personData } = person;
                    
                    await state.db.savePerson(personData);
                    
                    if (faces && faces.length > 0) {
                        for (const face of faces) {
                            await state.db.saveFace({
                                ...face,
                                personId: personId
                            });
                        }
                    }
                    migratedCount++;
                }

                if (migratedCount > 0) {
                    localStorage.removeItem('biometricData');
                    showNotification(`‚úÖ Migrated ${migratedCount} person(s) to IndexedDB`, 'success');
                }
            } catch (error) {
                console.error('Migration error:', error);
            }
        }

        // ===== Update Storage Info =====
        async function updateStorageInfo() {
            try {
                const estimate = await state.db.getStorageEstimate();
                const usedMB = (estimate.usage / 1024 / 1024).toFixed(2);
                const quotaMB = (estimate.quota / 1024 / 1024).toFixed(0);
                const usedPercent = ((estimate.usage / estimate.quota) * 100).toFixed(1);
                
                elements.storageText.textContent = `${usedMB} MB / ${quotaMB} MB (${usedPercent}%)`;
            } catch (error) {
                elements.storageText.textContent = 'Storage info unavailable';
            }
        }

        // ===== Load Face-API Models =====
        async function loadFaceApiModels() {
            showNotification('üîÑ Loading face recognition models...', 'info');
            
            try {
                const MODEL_URL = './model';
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
                await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
                
                state.modelsLoaded = true;
                showNotification('‚úÖ Face recognition models loaded!', 'success');
                return true;
            } catch (error) {
                console.error('Model loading error:', error);
                state.modelsLoaded = false;
                showNotification('‚ö†Ô∏è Failed to load models. Place model files in ./model directory.', 'error');
                showWarningBanner();
                return false;
            }
        }

        // ===== Show Warning Banner =====
        function showWarningBanner() {
            const warningDiv = document.createElement('div');
            warningDiv.className = 'bg-yellow-50 border-l-4 border-yellow-400 p-4 mx-4 mb-6 rounded-lg shadow-md';
            warningDiv.innerHTML = `
                <div class="flex items-start">
                    <span class="text-3xl mr-3">‚ö†Ô∏è</span>
                    <div class="flex-1">
                        <h3 class="text-lg font-bold text-yellow-800 mb-2">Face Recognition Unavailable</h3>
                        <p class="text-sm text-yellow-700 mb-2">Face detection requires model files. Data management still works.</p>
                        <a href="https://github.com/justadudewhohacks/face-api.js-models" target="_blank" class="text-sm text-blue-600 hover:text-blue-800 underline font-medium">üì• Download models ‚Üí</a>
                    </div>
                </div>
            `;
            document.querySelector('main').insertBefore(warningDiv, document.querySelector('main').firstChild);
        }

        // ===== Event Listeners Setup =====
        function setupEventListeners() {
            elements.addPersonBtn.addEventListener('click', () => {
                document.getElementById('personName').value = '';
                document.getElementById('personDescription').value = '';
                elements.addPersonModal.style.display = 'block';
            });
            
            elements.importBtn.addEventListener('click', () => elements.importData.click());
            elements.importData.addEventListener('change', handleImportData);
            elements.exportBtn.addEventListener('click', handleExportAllData);
            
            elements.clearStorageBtn.addEventListener('click', () => {
                showConfirmModal('Are you sure you want to clear all biometric data? This action cannot be undone.', async () => {
                    await state.db.clearAll();
                    await renderPersonData();
                    await updateStorageInfo();
                    showNotification('‚úÖ All biometric data cleared', 'success');
                });
            });
            
            elements.matchBrowseBtn.addEventListener('click', () => elements.matchImageUpload.click());
            elements.matchImageUpload.addEventListener('change', handleMatchImageUpload);
            
            elements.matchDropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.matchDropArea.classList.add('dragover');
            });
            
            elements.matchDropArea.addEventListener('dragleave', () => {
                elements.matchDropArea.classList.remove('dragover');
            });
            
            elements.matchDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.matchDropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    handleMatchFiles(e.dataTransfer.files);
                }
            });
            
            document.querySelectorAll('.close').forEach(closeBtn => {
                closeBtn.addEventListener('click', closeAllModals);
            });
            
            document.getElementById('cancelAddPerson').addEventListener('click', () => {
                elements.addPersonModal.style.display = 'none';
            });
            
            document.getElementById('cancelEditPerson').addEventListener('click', () => {
                elements.editPersonModal.style.display = 'none';
            });
            
            window.addEventListener('click', (e) => {
                if (e.target.classList.contains('modal')) {
                    closeAllModals();
                }
            });
            
            document.getElementById('addPersonForm').addEventListener('submit', handleAddPerson);
            document.getElementById('editPersonForm').addEventListener('submit', handleEditPerson);
            
            document.getElementById('editBrowseBtn').addEventListener('click', () => {
                document.getElementById('editImageUpload').click();
            });
            
            document.getElementById('editImageUpload').addEventListener('change', (e) => {
                if (e.target.files.length) {
                    processEditImages(e.target.files);
                    e.target.value = '';
                }
            });
            
            const editDropArea = document.getElementById('editDropArea');
            editDropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                editDropArea.classList.add('dragover');
            });
            
            editDropArea.addEventListener('dragleave', () => {
                editDropArea.classList.remove('dragover');
            });
            
            editDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                editDropArea.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    processEditImages(e.dataTransfer.files);
                }
            });
        }

        // ===== Close All Modals =====
        function closeAllModals() {
            elements.addPersonModal.style.display = 'none';
            elements.editPersonModal.style.display = 'none';
            elements.confirmModal.style.display = 'none';
        }

        // ===== Add Person =====
        async function handleAddPerson(e) {
            e.preventDefault();
            const name = document.getElementById('personName').value.trim();
            const description = document.getElementById('personDescription').value.trim();
            
            if (!name) {
                showNotification('‚ö†Ô∏è Please enter a name', 'error');
                return;
            }
            
            await createNewPerson(name, description);
            await renderPersonData();
            elements.addPersonModal.style.display = 'none';
            showNotification(`‚úÖ Person "${name}" added successfully`, 'success');
        }

        // ===== Edit Person =====
        async function handleEditPerson(e) {
            e.preventDefault();
            const personId = document.getElementById('editPersonId').value;
            const name = document.getElementById('editPersonName').value.trim();
            const description = document.getElementById('editPersonDescription').value.trim();
            
            if (!name) {
                showNotification('‚ö†Ô∏è Please enter a name', 'error');
                return;
            }
            
            const person = await state.db.getPerson(personId);
            if (person) {
                person.name = name;
                person.description = description;
                await state.db.savePerson(person);
                await renderPersonData();
                elements.editPersonModal.style.display = 'none';
                showNotification(`‚úÖ Person "${name}" updated successfully`, 'success');
            }
        }

        // ===== Create New Person =====
        async function createNewPerson(name, description = '') {
            const personId = `person_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            const person = {
                id: personId,
                name: name,
                description: description,
                createdAt: new Date().toISOString()
            };
            await state.db.savePerson(person);
            return personId;
        }

        // ===== Render Person Data =====
        async function renderPersonData() {
            elements.personContainer.innerHTML = '';
            
            const persons = await state.db.getAllPersons();
            
            if (persons.length === 0) {
                elements.personContainer.innerHTML = `
                    <div class="col-span-full text-center py-16">
                        <div class="text-6xl mb-4">üë•</div>
                        <p class="text-gray-500 text-lg">No persons available</p>
                        <p class="text-gray-400 text-sm mt-2">Add a person to get started</p>
                    </div>
                `;
                return;
            }
            
            for (const person of persons) {
                const faces = await state.db.getFacesByPerson(person.id);
                const faceCount = faces.length;
                
                const card = document.createElement('div');
                card.className = 'person-card rounded-xl shadow-md overflow-hidden';
                card.innerHTML = `
                    <div class="p-6">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <h3 class="text-xl font-bold text-gray-900">${person.name}</h3>
                                <p class="text-sm text-gray-600 mt-1">
                                    <span class="badge ${faceCount > 0 ? 'badge-success' : 'badge-warning'}">
                                        ${faceCount} face${faceCount !== 1 ? 's' : ''}
                                    </span>
                                </p>
                            </div>
                            <div class="flex gap-1">
                                <button class="export-person-btn icon-btn icon-download" data-id="${person.id}" title="Export">‚¨á</button>
                                <button class="edit-person-btn icon-btn icon-edit" data-id="${person.id}" title="Edit">‚úè</button>
                                <button class="delete-person-btn icon-btn icon-delete" data-id="${person.id}" title="Delete">üóë</button>
                            </div>
                        </div>
                        <p class="text-gray-700 text-sm mb-4 min-h-[40px]">${person.description || 'No description provided'}</p>
                        <div class="mb-4">
                            <div class="flex justify-between text-xs text-gray-500 mb-2">
                                <span>Face Data</span>
                                <span>${faceCount} ${faceCount === 1 ? 'entry' : 'entries'}</span>
                            </div>
                            <div class="progress-bar-container">
                                <div class="progress-bar-fill" style="width: ${Math.min(100, faceCount * 10)}%"></div>
                            </div>
                        </div>
                        <button class="add-images-btn w-full px-4 py-3 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-lg hover:from-indigo-600 hover:to-purple-700 transition-all shadow-md hover:shadow-lg font-semibold" data-id="${person.id}">
                            üì∏ Add Face Images
                        </button>
                    </div>
                `;
                
                elements.personContainer.appendChild(card);
            }
            
            document.querySelectorAll('.export-person-btn').forEach(btn => {
                btn.addEventListener('click', (e) => exportPersonData(e.currentTarget.dataset.id));
            });
            
            document.querySelectorAll('.edit-person-btn').forEach(btn => {
                btn.addEventListener('click', (e) => openEditPersonModal(e.currentTarget.dataset.id));
            });
            
            document.querySelectorAll('.delete-person-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const personId = e.currentTarget.dataset.id;
                    showConfirmModal('Are you sure you want to delete this person and all face data?', async () => {
                        const person = await state.db.getPerson(personId);
                        await state.db.deletePerson(personId);
                        await renderPersonData();
                        await updateStorageInfo();
                        showNotification(`‚úÖ Person "${person.name}" deleted`, 'success');
                    });
                });
            });
            
            document.querySelectorAll('.add-images-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    if (!state.modelsLoaded) {
                        showNotification('‚ö†Ô∏è Face recognition models not loaded', 'error');
                        return;
                    }
                    const personId = e.currentTarget.dataset.id;
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.multiple = true;
                    input.onchange = (e) => {
                        if (e.target.files.length) {
                            processImagesForPerson(e.target.files, personId);
                        }
                    };
                    input.click();
                });
            });
        }

        // ===== Open Edit Person Modal =====
        async function openEditPersonModal(personId) {
            const person = await state.db.getPerson(personId);
            if (!person) return;
            
            document.getElementById('editPersonId').value = personId;
            document.getElementById('editPersonName').value = person.name;
            document.getElementById('editPersonDescription').value = person.description || '';
            
            const faceImagesContainer = document.getElementById('editFaceImages');
            faceImagesContainer.innerHTML = '';
            
            const faces = await state.db.getFacesByPerson(personId);
            
            if (faces.length > 0) {
                for (const face of faces) {
                    const faceDiv = document.createElement('div');
                    faceDiv.className = 'relative group';
                    faceDiv.innerHTML = `
                        <img src="${face.imageData}" class="face-thumbnail" data-id="${face.id}" alt="Face">
                        <button class="remove-face-btn absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center shadow-lg transition-all opacity-0 group-hover:opacity-100" data-id="${face.id}" title="Remove">
                            <span class="text-white font-bold text-lg">‚úï</span>
                        </button>
                    `;
                    faceImagesContainer.appendChild(faceDiv);
                }
                
                document.querySelectorAll('.remove-face-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        removeFaceFromPerson(personId, e.currentTarget.dataset.id);
                    });
                });
            } else {
                faceImagesContainer.innerHTML = '<p class="text-gray-500 text-sm text-center py-4">No face images added yet</p>';
            }
            
            elements.editPersonModal.style.display = 'block';
        }

        // ===== Process Images For Person =====
        async function processImagesForPerson(files, personId) {
            const person = await state.db.getPerson(personId);
            if (!person) {
                showNotification('‚ö†Ô∏è Person not found', 'error');
                return;
            }
            
            elements.processingModal.style.display = 'block';
            elements.processingBar.style.width = '0%';
            elements.processingText.textContent = '0%';
            elements.processingStatus.innerHTML = '<div class="spinner mx-auto mb-3"></div><p>Initializing...</p>';
            
            try {
                const totalFiles = files.length;
                let processedCount = 0;
                let successCount = 0;
                
                for (let i = 0; i < totalFiles; i++) {
                    const file = files[i];
                    processedCount++;
                    const progress = Math.round((processedCount / totalFiles) * 100);
                    
                    elements.processingBar.style.width = `${progress}%`;
                    elements.processingText.textContent = `${progress}%`;
                    elements.processingStatus.innerHTML = `<p>Processing ${file.name}</p><p class="text-sm text-gray-500 mt-1">(${processedCount}/${totalFiles})</p>`;
                    
                    try {
                        await processSingleImageForPerson(file, personId);
                        successCount++;
                    } catch (error) {
                        console.error(`Failed: ${file.name}`, error);
                    }
                }
                
                elements.processingStatus.innerHTML = `<p class="text-green-600 font-semibold">‚úÖ Complete!</p><p class="text-sm mt-2">Processed ${successCount} of ${totalFiles} images</p>`;
                
                if (successCount > 0) {
                    showNotification(`‚úÖ Successfully processed ${successCount} image(s)`, 'success');
                }
                
                await renderPersonData();
                await updateStorageInfo();
                
                setTimeout(() => {
                    elements.processingModal.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                elements.processingStatus.innerHTML = `<p class="text-red-600 font-semibold">‚ùå Error</p><p class="text-sm mt-2">${error.message}</p>`;
                showNotification('‚ö†Ô∏è Processing failed', 'error');
            }
        }

        // ===== Process Single Image =====
        async function processSingleImageForPerson(file, personId) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.src = e.target.result;
                };
                
                reader.onerror = () => reject(new Error(`Failed to read: ${file.name}`));
                
                img.onload = async () => {
                    try {
                        const detections = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions())
                            .withFaceLandmarks()
                            .withFaceDescriptors();
                        
                        if (detections.length === 0) {
                            resolve();
                            return;
                        }
                        
                        for (const detection of detections) {
                            const faceId = `face_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                            
                            await state.db.saveFace({
                                id: faceId,
                                personId: personId,
                                descriptor: Array.from(detection.descriptor),
                                imageData: img.src, // Store as data URL (high quality)
                                timestamp: new Date().toISOString(),
                                metadata: {
                                    filename: file.name,
                                    fileSize: file.size
                                }
                            });
                        }
                        
                        resolve();
                    } catch (error) {
                        reject(new Error(`Face detection failed: ${error.message}`));
                    }
                };
                
                img.onerror = () => reject(new Error(`Failed to load: ${file.name}`));
                reader.readAsDataURL(file);
            });
        }

        // ===== Process Edit Images =====
        async function processEditImages(files) {
            const personId = document.getElementById('editPersonId').value;
            if (!personId) {
                showNotification('‚ö†Ô∏è Person not found', 'error');
                return;
            }
            
            if (!state.modelsLoaded) {
                showNotification('‚ö†Ô∏è Face recognition models not loaded', 'error');
                return;
            }
            
            elements.processingModal.style.display = 'block';
            elements.processingBar.style.width = '0%';
            elements.processingText.textContent = '0%';
            elements.processingStatus.innerHTML = '<div class="spinner mx-auto mb-3"></div><p>Initializing...</p>';
            
            try {
                const totalFiles = files.length;
                let processedCount = 0;
                let successCount = 0;
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    processedCount++;
                    const progress = Math.round((processedCount / totalFiles) * 100);
                    
                    elements.processingBar.style.width = `${progress}%`;
                    elements.processingText.textContent = `${progress}%`;
                    elements.processingStatus.innerHTML = `<p>Processing ${file.name}</p><p class="text-sm text-gray-500 mt-1">(${processedCount}/${totalFiles})</p>`;
                    
                    try {
                        await processSingleImageForPerson(file, personId);
                        successCount++;
                    } catch (error) {
                        console.error(`Failed: ${file.name}`, error);
                    }
                }
                
                elements.processingStatus.innerHTML = `<p class="text-green-600 font-semibold">‚úÖ Added ${successCount} images!</p>`;
                
                if (successCount > 0) {
                    showNotification(`‚úÖ Added ${successCount} image(s)!`, 'success');
                }
                
                await updateStorageInfo();
                
                setTimeout(() => {
                    elements.processingModal.style.display = 'none';
                    openEditPersonModal(personId);
                }, 1500);
                
            } catch (error) {
                elements.processingStatus.innerHTML = `<p class="text-red-600">‚ùå Error: ${error.message}</p>`;
                showNotification('‚ö†Ô∏è Failed to add images', 'error');
            }
        }

        // ===== Remove Face =====
        async function removeFaceFromPerson(personId, faceId) {
            await state.db.deleteFace(faceId);
            await updateStorageInfo();
            await openEditPersonModal(personId);
            showNotification('‚úÖ Face removed successfully', 'success');
        }

        // ===== Handle Match Image Upload =====
        function handleMatchImageUpload(e) {
            if (e.target.files.length) {
                handleMatchFiles(e.target.files);
                e.target.value = '';
            }
        }

        // ===== Handle Match Files =====
        function handleMatchFiles(files) {
            if (!state.modelsLoaded) {
                showNotification('‚ö†Ô∏è Face recognition models not loaded', 'error');
                return;
            }
            
            const imageFile = Array.from(files).find(file => file.type.startsWith('image/'));
            
            if (!imageFile) {
                showNotification('‚ö†Ô∏è Please select a valid image file', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                elements.matchImagePreview.innerHTML = `
                    <div class="relative">
                        <img src="${e.target.result}" class="face-image">
                        <div class="mt-2 text-center text-sm text-gray-600">${imageFile.name}</div>
                    </div>
                `;
                state.currentMatchImage = e.target.result;
                performMatching(e.target.result);
            };
            reader.readAsDataURL(imageFile);
        }

        // ===== Perform Face Matching =====
        async function performMatching(imageSrc) {
            elements.matchResults.innerHTML = `
                <div class="text-center py-12">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="text-gray-600 font-medium">Analyzing faces...</p>
                </div>
            `;
            
            try {
                const img = new Image();
                img.src = imageSrc;
                
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error('Failed to load image'));
                });
                
                const detections = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions())
                    .withFaceLandmarks()
                    .withFaceDescriptors();
                
                if (detections.length === 0) {
                    elements.matchResults.innerHTML = `
                        <div class="text-center py-12 bg-red-50 rounded-xl border-2 border-red-200">
                            <div class="text-5xl mb-3">‚ö†Ô∏è</div>
                            <p class="text-red-600 font-bold text-lg">No Faces Detected</p>
                        </div>
                    `;
                    return;
                }
                
                const persons = await state.db.getAllPersons();
                
                if (persons.length === 0) {
                    elements.matchResults.innerHTML = `
                        <div class="text-center py-12 bg-yellow-50 rounded-xl border-2 border-yellow-200">
                            <div class="text-5xl mb-3">üìã</div>
                            <p class="text-yellow-800 font-bold text-lg">No Person Data</p>
                        </div>
                    `;
                    return;
                }
                
                const results = [];
                
                for (const person of persons) {
                    const faces = await state.db.getFacesByPerson(person.id);
                    if (faces.length === 0) continue;
                    
                    const personResults = [];
                    
                    for (const face of faces) {
                        const storedDescriptor = new faceapi.LabeledFaceDescriptors(
                            person.id,
                            [new Float32Array(face.descriptor)]
                        );
                        
                        const faceMatcher = new faceapi.FaceMatcher(storedDescriptor);
                        const bestMatch = faceMatcher.findBestMatch(detections[0].descriptor);
                        
                        personResults.push({
                            personName: person.name,
                            distance: bestMatch.distance,
                            matchPercentage: Math.max(0, Math.min(100, Math.round((1 - bestMatch.distance) * 100)))
                        });
                    }
                    
                    if (personResults.length > 0) {
                        const best = personResults.reduce((p, c) => p.matchPercentage > c.matchPercentage ? p : c);
                        results.push(best);
                    }
                }
                
                results.sort((a, b) => b.matchPercentage - a.matchPercentage);
                
                if (results.length === 0) {
                    elements.matchResults.innerHTML = `
                        <div class="text-center py-12 bg-gray-50 rounded-xl border-2 border-gray-200">
                            <div class="text-5xl mb-3">üîç</div>
                            <p class="text-gray-700 font-bold text-lg">No Matches Found</p>
                        </div>
                    `;
                    return;
                }
                
                const top = results[0];
                const matchIcon = top.matchPercentage > 70 ? '‚úÖ' : top.matchPercentage > 40 ? '‚ö†Ô∏è' : '‚ùå';
                const matchText = top.matchPercentage > 70 ? 'High Confidence Match' : top.matchPercentage > 40 ? 'Possible Match' : 'Low Confidence';
                
                elements.matchResults.innerHTML = `
                    <div class="mb-4 p-4 rounded-xl border-2 ${top.matchPercentage > 70 ? 'bg-green-50 border-green-300' : top.matchPercentage > 40 ? 'bg-yellow-50 border-yellow-300' : 'bg-red-50 border-red-300'}">
                        <div class="flex items-center gap-2">
                            <span class="text-2xl">${matchIcon}</span>
                            <p class="font-bold ${top.matchPercentage > 70 ? 'text-green-800' : top.matchPercentage > 40 ? 'text-yellow-800' : 'text-red-800'}">${matchText}</p>
                        </div>
                    </div>
                    <div class="space-y-3">
                        ${results.slice(0, 5).map(r => `
                            <div class="match-result p-4 rounded-xl border-2 ${r.matchPercentage > 70 ? 'bg-green-50 border-green-200' : r.matchPercentage > 40 ? 'bg-yellow-50 border-yellow-200' : 'bg-gray-50 border-gray-200'}">
                                <div class="flex justify-between items-center mb-3">
                                    <h4 class="font-bold text-lg text-gray-900">${r.personName}</h4>
                                    <span class="text-2xl font-bold ${r.matchPercentage > 70 ? 'text-green-600' : r.matchPercentage > 40 ? 'text-yellow-600' : 'text-gray-600'}">${r.matchPercentage}%</span>
                                </div>
                                <div class="progress-bar-container mb-2">
                                    <div class="progress-bar-fill ${r.matchPercentage > 70 ? 'bg-gradient-to-r from-green-500 to-green-600' : r.matchPercentage > 40 ? 'bg-gradient-to-r from-yellow-500 to-yellow-600' : 'bg-gradient-to-r from-gray-400 to-gray-500'}" style="width: ${r.matchPercentage}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                showNotification(`üéØ Best match: ${top.personName} (${top.matchPercentage}%)`, 'success');
                
            } catch (error) {
                elements.matchResults.innerHTML = `
                    <div class="text-center py-12 bg-red-50 rounded-xl border-2 border-red-200">
                        <div class="text-5xl mb-3">‚ùå</div>
                        <p class="text-red-600 font-bold text-lg">Matching Error</p>
                        <p class="text-gray-600 text-sm mt-2">${error.message}</p>
                    </div>
                `;
                showNotification('‚ö†Ô∏è Matching failed', 'error');
            }
        }

        // ===== Import Data =====
        async function handleImportData(e) {
            const files = Array.from(e.target.files);
            if (!files.length) return;
            
            let importedCount = 0;
            
            for (const file of files) {
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    
                    if (data.id && data.name) {
                        const { faces, ...personData } = data;
                        await state.db.savePerson(personData);
                        
                        if (faces && faces.length > 0) {
                            for (const face of faces) {
                                await state.db.saveFace({
                                    ...face,
                                    personId: data.id
                                });
                            }
                        }
                        importedCount++;
                    } else if (typeof data === 'object') {
                        for (const key in data) {
                            if (data[key].id && data[key].name) {
                                const { faces, ...personData } = data[key];
                                await state.db.savePerson(personData);
                                
                                if (faces && faces.length > 0) {
                                    for (const face of faces) {
                                        await state.db.saveFace({
                                            ...face,
                                            personId: data[key].id
                                        });
                                    }
                                }
                                importedCount++;
                            }
                        }
                    }
                } catch (error) {
                    showNotification(`‚ö†Ô∏è Failed to import ${file.name}`, 'error');
                }
            }
            
            if (importedCount > 0) {
                await renderPersonData();
                await updateStorageInfo();
                showNotification(`‚úÖ Imported ${importedCount} person(s)`, 'success');
            }
            
            e.target.value = '';
        }

        // ===== Export All Data =====
        async function handleExportAllData() {
            const persons = await state.db.getAllPersons();
            
            if (persons.length === 0) {
                showNotification('‚ö†Ô∏è No data to export', 'warning');
                return;
            }
            
            try {
                const exportData = {};
                
                for (const person of persons) {
                    const faces = await state.db.getFacesByPerson(person.id);
                    exportData[person.id] = {
                        ...person,
                        faces: faces
                    };
                }
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const filename = `biometric_data_all_${new Date().toISOString().slice(0, 10)}.json`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                
                URL.revokeObjectURL(url);
                showNotification(`‚úÖ Exported ${persons.length} person(s)`, 'success');
            } catch (error) {
                showNotification('‚ö†Ô∏è Export failed: ' + error.message, 'error');
            }
        }

        // ===== Export Person Data =====
        async function exportPersonData(personId) {
            const person = await state.db.getPerson(personId);
            if (!person) {
                showNotification('‚ö†Ô∏è Person not found', 'error');
                return;
            }
            
            try {
                const faces = await state.db.getFacesByPerson(personId);
                const exportData = {
                    ...person,
                    faces: faces
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const safeName = person.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const filename = `person_${safeName}_${new Date().toISOString().slice(0, 10)}.json`;
                
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.click();
                
                URL.revokeObjectURL(url);
                showNotification(`‚úÖ Exported "${person.name}" with ${faces.length} face(s)`, 'success');
            } catch (error) {
                showNotification('‚ö†Ô∏è Export failed', 'error');
            }
        }

        // ===== Show Notification =====
        function showNotification(message, type = 'info') {
            const bgColor = {
                success: '#10b981',
                error: '#ef4444',
                warning: '#f59e0b',
                info: '#3b82f6'
            }[type] || '#3b82f6';
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.backgroundColor = bgColor;
            notification.innerHTML = `
                <div class="flex items-center justify-between gap-3">
                    <span class="flex-1 font-medium">${message}</span>
                    <button class="text-white hover:text-gray-200 font-bold text-xl" onclick="this.parentElement.parentElement.classList.add('hiding'); setTimeout(() => this.parentElement.parentElement.remove(), 300)">‚úï</button>
                </div>
            `;
            
            elements.notificationContainer.appendChild(notification);
            
            setTimeout(() => {
                notification.classList.add('hiding');
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        // ===== Show Confirm Modal =====
        function showConfirmModal(message, onConfirm) {
            document.getElementById('confirmMessage').textContent = message;
            elements.confirmModal.style.display = 'block';
            
            const confirmBtn = document.getElementById('confirmAction');
            const cancelBtn = document.getElementById('cancelConfirm');
            
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
            
            newConfirmBtn.onclick = () => {
                onConfirm();
                elements.confirmModal.style.display = 'none';
            };
            
            newCancelBtn.onclick = () => {
                elements.confirmModal.style.display = 'none';
            };
        }
    </script>
</body>
</html>
